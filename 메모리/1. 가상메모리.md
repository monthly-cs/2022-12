이 문서는 2022년 11월 16일에 @codeing999에 의해서 작성되었습니다.
```
1. 가상메모리
  1.1. 가상메모리란?
  1.2. 가상메모리 사용의 시나리오
  1.3. 가상메모리를 위한 운영체제 정책
```

# 1. 가상메모리
## 1.1. 가상메모리란?
- 프로세스의 모든 메모리 참조는 논리주소이고, 프로세스 수행시간에 동적으로 물리 주소로 변환된다.
- 한 프로세스의 주소 공간은 여러 블록(페이지 혹은 세그먼트)로 분할될 수 있고. 이 블록들은 메모리의 연속된 영역에 위치할 필요가 없다.
<br>

여기까지는 단편화를 최소화하기 위한 기법들인 [논리 주소와 페이징 혹은 세그멘테이션](https://github.com/monthly-cs/2022-11/blob/main/%EB%A9%94%EB%AA%A8%EB%A6%AC/2.%20%ED%8E%98%EC%9D%B4%EC%A7%95%2C%20%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98.md#1-%EB%AC%BC%EB%A6%AC-%EC%A3%BC%EC%86%8Cphysical-address%EC%99%80-%EB%85%BC%EB%A6%AC-%EC%A3%BC%EC%86%8Clogical-address)  사용 시의 특성이다. 

이 두 특성들들이 만족된다면, <br>
수행 중인 프로세스의 모든 블록이 주기억장치에 적재되어 있을 필요가 없어지게 된다. <br>
가상메모리는 논리주소에 대응되는 물리주소의 영역을 보조기억장치로 확대한 것으로, <br>이는 다음과 같은 장점을 갖는다. 

- 각 프로세스의 일부 블록들만 메모리에 적재하기 때문에 보다 많은 프로세를 적재할 수 있어서, 프로세서의 활용도가 높아진다.
- 메모리보다 큰 프로세스를 수행할 수 있다.

![image](https://user-images.githubusercontent.com/109027875/205412621-b9dbc05f-90b8-404c-b31b-8717c9bd4474.png)


## 1.2. 가상메모리 사용의 시나리오

```
1. 운영체제는 새로운 프로세스를 메모리에 반입할 때, 초기에 참조될 코드와 데이터가 포함되는 몇개의 블록만을 반입한다.
2. 프로세스가 이 메모리에 적대된 적재 집합(resident set)에 포함된 주소를 참조할 때에는 순조롭게 수행된다.
3. 메모리에 적재되지 않은 논리 주소가 참조될 경우 프로세서는 메모리 접근 오류(memory access fault) 인터럽트를 발생시킨다.
4. 운영체제는 디스크 입출력 요청을한 후 다른 프로세스에게 CPU를 넘겨 디스크 입출력이 진행되는 동안 수행될 수 있게 한다.
5. 요청된 디스크 입출력이 끝나면 입출력 인터럽트가 발생하게 되고, 
  이를 통해 제어를 돌려 받은 운영체제는 이전에 메모리 접근 오류를 발싱시켜 블록되었던 프로세스를 준비 상태로 전환시킨다.
```

## 1.3. 가상메모리를 위한 운영체제 정책
- 반입 정책
  - 요구 페이징(demand Paging)
  - 선페이징(prepaging) 
- 배치 정책
- 교체 정책
  - 최적(optimal)
  - LRU(Least Recently Used)
  - FIFO(First-In-First-Out)
  - 클록(clock)
- 적재 집합 관리
  - 적재 집합 크기
    - 고정
    - 가변
  - 교체 범위
    - 전역
    - 지역
- 클리닝 정책
  - 요구 클리닝(demand cleaning)
  - 선클리닝(precleaning)
- 부하 제어(load control)
  - 다중프로그래밍의 차수 

# references
- 박미진 컴퓨터 일반
- 운영체제 내부 구조 및 설계 원리
