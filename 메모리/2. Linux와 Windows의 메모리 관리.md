이 문서는 2022년 12월 11일에 @codeing999에 의해서 작성되었습니다.
```
1. Unix의 메모리 관리
  1.1. 페이징 시스템
    1.1.1. 자료구조
      1.1.1.1. 페이지 테이블(page table)
      1.1.1.2. 디스크 블록 디스크립터(disk block descriptor)
      1.1.1.3. 페이지 프레임 데이터 테이블(page frame data table)
      1.1.1.4. 스왑 사용 테이블(swap-use table) 
    1.1.2. 페이지 교체
  1.2. 커널 메모리 할당자
2. Linux의 메모리 관리
  2.1. Linux 가상 메모리
    2.1.1. 가상 메모리 주소지정
    2.1.2. 페이지 할당
    2.1.3. 페이지교체 알고리즘(Least Frequently Used정책 범주)
  2.2. 커널 메모리 할당
3. Windows의 메모리 관리
  3.1. Windows 가상 주소 맵
  3.2. Windows 페이징
4. Windows와 Linux 비교
References
```

# 1. Unix의 메모리 관리
페이징 기반 가상 메모리를 활용

페이징 시스템(paging system)과 커널 메모리 할당자(kernerl memory allocator) 두 가지 메모리 관리 기법이 있다. 페이징 시스템이 사용자 프로세스나 디스크 입출력에 대해서는 효과적이지만 커널용 메모리 관리에는 적합하지 않기 때문에 커널용 메모리 관리를 위해 커널 메모리 할당자 기법이 도입되었다.

## 1.1. 페이징 시스템

페이징 기반 가상 메모리를 위해 UNIX는 몇 가지 자료구조를 사용한다.

### 1.1.1. 자료구조
#### 1.1.1.1. 페이지 테이블(page table)
일반적으로 프로세스마다 하나의 페이지 테이블이 있으며, 각 테이블 항목은 해당 프로세스의 페이지 하나와 대응된다.
![image](https://user-images.githubusercontent.com/109027875/206901307-18069171-e2c5-4701-867e-ca8de187d7f3.png)
- page frame number : 실메모리를 참조하기 위한 프레임 번호
- Age : 페이지가 참조되지 않고 얼마나 경과되었는지 표시. 이 필드의 길이나 내용은 프로세서에 의존한다.
- Copy on write : 두 개 이상의 프로세스가 복사해야할 페이지를 복사하지 않고 원본 페이지를 공유하고 있을 때 설정. 한 프로세스가 페이지에 쓰기 작업을 시도하면, 그 페이지를 공유하는 다른 프로세스들을 위해 우선적으로 별개의 복사본을 만들어야 한다. 이 기능은 복사본이 실질적으로 필요해질 때까지 복사 작업을 연기함으로써, 필요치 않을 경우 복사 작업을 하지 않아도 되게 한다.
- Modify : 페이지가 변경되었음을 나타냄
- Reference : 페이지가 참조되었는지를 나타냄. 이 비트는 페이지가 처음 적재될 때 0으로 초기화되고, 주기적으로 페이지 교체 알고리즘에 의해 0으로 설정된다.
- Valid : 페이지가 주기억장치에 있는지를 나타냄.
- Protect : 쓰기 작어비 허용되어 있는지를 나타냄.

#### 1.1.1.2. 디스크 블록 디스크립터(disk block descriptor)
프로세스의 각 페이지에 대해 그 디스크 저장본(disk copy)을 기술해 준다.
![image](https://user-images.githubusercontent.com/109027875/206901353-15e273c6-de89-4956-a384-31f8ce000d47.png)
- Swap device number : 해당 페이지가 저장되어 있는 보조기억장치의 논리적 장치 번호. 이는 다수의 장치가 스와핑용으로 사용될 수 있게 한다.

- Device block number : 스왑 장치 상에서 페이지의 블록 위치

- Type of storage : 저장 장소는 스왑 유닛이거나 수행 파일일 수 있다. 후자의 경우, 초기화 시 할당된 가상 메모리를 지워야하는지를 나타내는 표시가 있다.

#### 1.1.1.3. 페이지 프레임 데이터 테이블(page frame data table)
주기억장치의 각 프레임마다 한 항목이 대응되고, 프레임 번호로 인덱싱된다. 교체 알고리즘에 의해 사용된다.
![image](https://user-images.githubusercontent.com/109027875/206901391-c10b5873-12d5-4097-9a57-59091217b560.png)

- Page state : 해당 프레임이 가용 상태인지 혹은 연관된 페이지가 있는지를 나타냄. 후자의 경우 "스왑 장치 상", "수행 파일 안", "DMA 진행 중"등의 페이지 상태가 명시된다.

- Reference counter : 해당 페이지를 참조하고 있는 프로세스의 수

- Logical device : 해당 페이지의 복사본을 포함한 논리 장치

- Block number : 논리 장치 상에 있는 해당 페이지 복사본의 블록 위치

- Pfdata pointer : 가용 페이지 리스트와 페이지 해시 큐 상에 있는 다른 Pfdata 테이블 항목에 대한 포인터

#### 1.1.1.4. 스왑 사용 테이블(swap-use table) 
스왑 장치별로 하나의 스왑 사용 테이블이 있으며, 각 테이블 항목은 장치 상의 페이지 하나와 대응된다.
![image](https://user-images.githubusercontent.com/109027875/206901397-3eef24c6-8576-4d4b-8652-905c781006d2.png)

- Reference counter :스왑 장치 상의 해당 페이지를 가리키는 페이지 테이블 항목의 수

- Page/storage unit number : 저장 유닛 상의 페이지 식별자

### 1.1.2. 페이지 교체
- 두 바늘 클록 알고리(two-handed clock algorithm)
  - 처음 적재된 페이지의 참조 비트는 0, 참조될 때 1
  - ‘선행바늘(fronthand)’은 프레임들을 스캔하면서 각 페이지의 참조비트를 0으로 만들고, ‘어느 정도’의 시간이 지난 후, ‘후행바늘(backhand)’이 동일 페이지들을 스캔하면서 참조비트
  값 조사
  - 참조비트 값이 1인 프레임은 교체 대상에서 제외하고, 0이면 해당 페이지를 반출될 페이지들의 리스트로 이동
![image](https://user-images.githubusercontent.com/109027875/206902717-73e34885-c5a1-41a3-9d58-d806f2d6617b.png)


## 1.2. 커널 메모리 할당자

- 게으른 버디 시스템(lazy buddy system)
  -  특정 크기의 블록에 대한 요구량이 시간 상으로 완만하게 변함으로 분할과 통합을 늦춘다.

# 2. Linux의 메모리 관리
## 2.1. Linux 가상 메모리
### 2.1.1. 가상 메모리 주소지정
리눅스는 다음 유형의 테이블(각 테이블의 크기는 페이지 크기와 동일)로 구성된 3단계 페이지 테이블 구조를 사용한다.
![image](https://user-images.githubusercontent.com/109027875/206901883-1ba536f8-f1b4-46ad-9e6a-931636620ccf.png)
- 페이지 디렉토리
- 페이지 중간 디렉토리
- 페이지 테이블

### 2.1.2. 페이지 할당
  페이지 반입/반출 효율 높이기 위해 연속된 페이지 블록들을 연속된 프레임에 사상
### 2.1.3. 페이지교체 알고리즘(Least Frequently Used정책 범주)
  - 각 페이지에 대해 8비트 변수 age 설정
  - 참조될 때 age 값 증가, 주기적으로 전체 페이지 스캔하며 감소
  - age 값이 적을수록 보다 적합한 교체 후보
  
## 2.2. 커널 메모리 할당
  - 페이지 할당: 버디 알고리즘을 이용해 페이지 배수 크기 할당
  - 슬랩 할당(slab allocation): 할당된 페이지 내에 작은 메모리 블록(chunks)을 수용하기 위해 도입. 버디 알고리즘과 유사하게 분할/통 하며 합 , 블록 크기 별로 연결리스트 유지

# 3. Windows의 메모리 관리
32비트 윈도우 아키텍쳐 : 4GB의 메모리 공간을 할당. 4GB의 물리 메모리가 사용가능할 경우 커널은 2GB, 앱 메모리는 2GB를 받게 된다. 커널모드 주소공간은 모든 프로세스들에 의해서 공유되고, 어플리케이션 모드 접근 공간은 각각의 유저 프로세스를 위해서 제공된다.

64비트 윈도우 아키텍쳐 : 16TB의 메모리 공간을 할당. 16TB의 실제 메모리가 사용가능할 경우, 커널은 8TB의 가상 주소 공간을 유저 어플리케이션 메모리는 8TB의 가상 주소 공간을 갖게된다.
## 3.1. Windows 가상 주소 맵
## 3.2. Windows 페이징
 



# 4. Windows와 Linux 비교

| Windows | Linux |
|:-|:-|
|물리 메모리는 필요할 때 동적으로 커널 주소 공간으로 사상된다.| 896MB까지의 물미 메모리는 정적으로 커널 주소 공간(32비트)에 사상되고, 나머지는 고정된 128MB 커널 주소 공간(불연속 사용도 가능함)에 동적으로 사상된다. |
| 커널과 응용은 TLB 효율을 위해 x86 large page를 사용할 수 있다. | - |
| 커널 및 드라이버의 코드나 데이터 중 많은 부분이 페이징되며, 부팅 후 초기화 코드는 제거된다. 페이지 테이블도 완전히 페이징된다. | 커널은 페이징되지 않는다. 모듈들은 페이징되지는 않지만 제거될 수 있다. |
| 물리 객체(파일, 장치, 물리 메모리)에 대한 주소 사상은 가상 주소 공간의 사용자 모드 할당과 구별된다. | 사용자 모드 주소는 물리 객체에 직접 사상된다. |
| AWE(Address Windwing Extensions: 오버레이 기법과 유사)를 이용할 경우, 큰 응용 프로그램은 직접 무릴 메모리를 할당받아 주소 공간에 사상시켜 활용할 수 있다. | - |
| Copy-on-write 지원 | Copy-on-write 지원 |
| 정상적인 사용자/커널 분할은 2GB/2GB이며, 3GB/1GB로 설정ㆍ부팅될 수 있다. | 정상적인 사용자/커널 분할은 3GB/1GB이다. Linux는 커널과 사용자의 주소 공간을 분리ㆍ수행할 수 있어서, 사용자에게 4GB를 모두 할당할 수도있다. |
| 캐시 관리자는 파일을 커널 주소 공간에 사상시켜 관리한다. 이를 위해 가상 메모리 관리자는 페이지들에 대한 대기 리스트(standby list)와 변경 리스트(modified list)를 이용하여 실질적인 페이징과 캐싱을 담당한다. | 페이지 캐시는 페이지에 대한 캐싱을구현하며, 페이징 시스템을 위한 "lookaside 캐시"로 사용된다. |
| 쓰레드는 캐시 관리자를 우회하여 직접 입출력을 수행할 수 있다. | 프로세스는 페이지 캐시를 우회할 수 있다. |
| PFN(페이지 프레임 번호) 데이터베이스는 중추적인 자료구조이다. PFN 내의 페이지들은 프로세스의 페이지 테이블에 등록되거나, standby list, modified list, free list, badd list 중 하나에 연결된다. | 프로세스의 주소 공간에서 제거된 페이지들은 페이지 캐시에 유지ㆍ관리된다. |
| 섹션 객체는 파일과 같이 사상 가능한 메모리 객체로, 요구생성(create-on-demand)되고 페이징되는 프로토타입 페이지 테이블을 포함하고 있다. 이 페이지 테이블은, 결함 발생한 페이지가 이미 트랜잭션으로 처리되고 있을 때를 포함하여, 각 페이지가 어디에 위치하는지 파악하는 데 사용될 수 있다. | 스왑 캐시는 폴트 발생 페이지에 대한 복수 개의 인스턴스를 관리하는 데 사용된다. |
| 커널 모드(시스템 프로세스)와 프로세스 모두에 대해 작업 집합(working set) 기반의 페이지 교체 알고리즘이 적용된다. | 페이지 교체에 전역 클록 알고리즘이 사용된다. |
| 보안을 목적으로, 페이지 파일들을 암호화하고 회수된 가용 페이지의 내용은 지운다. | - |
| 필요할 때 페이징 파일 내에 공간을 할당함으로써, 기록 작업은 반납된 페이지들의 그룹에 대해 지역화된다. 공유 페이지들은 섹션 객체와 연계된 프로토타입 페이지 테이블을 통해 간접 사용되어, 페이지 파일 공간은 즉시 반납될 수 있다. | 필요할 때 스왑 디스크 내에 공간을 할당함으로써, 기록 작업은 반납된 페이지들의 그룹에 대해 지역화된다. 공유 페이지들은 스왑 슬롯을 유지하는데, 스왑 슬롯은 모든 프로세스가 해당 페이지에 대한 폴트를 발생시켜 반입을 요구하게 될 때까지 유지된다. |

# References

[Windows Memory Management](https://www.geeksforgeeks.org/windows-memory-managment/)

[Understand and manage Windows 10 virtual memory](https://www.techtarget.com/searchenterprisedesktop/tip/Understand-and-manage-Windows-10-virtual-memory)

운영체제 내부구조 및 설계 원리
